Index: src/Chen/DictionaryTest.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import unittest\r\nfrom turtle import st\r\n\r\nfrom hypothesis import given\r\n\r\nfrom Dictionary import Dictionary\r\n# import Dictionary\r\n\r\n\r\nclass DictionaryTest(unittest.TestCase):\r\n    # unit test for add()\r\n    def test_add(self):\r\n        dictionary = Dictionary()\r\n        dictionary.add(\"score\", 89)\r\n        self.assertEqual(dictionary.to_list(), [(\"score\", 89)])\r\n        dictionary.add(\"score\", 78)\r\n        self.assertEqual(dictionary.to_list(), [(\"score\", [78, 89])])\r\n        dictionary.add(\"gender\", \"male\")\r\n        self.assertEqual(dictionary.to_list(), [(\"gender\", \"male\"), (\"score\", [78, 89])])\r\n\r\n        dictionary2 = Dictionary()\r\n        temp1 = [23, 34]\r\n        temp2 = [23, 34]\r\n        dictionary2.add(temp1, 'test_value_1')\r\n        dictionary2.add(temp2, 'value2')\r\n        self.assertEqual(dictionary2.to_list(), [((23, 34), ['test_value_1', 'value2'])])\r\n\r\n        # Exception test\r\n        # 1. Add repeated key-value.\r\n        dictionary.add(\"score\", 78)\r\n        self.assertEqual(dictionary.to_list(), [(\"gender\", \"male\"), (\"score\", [78, 89])])\r\n        # 2. Add invalid key\r\n        dictionary.add({'key1': 2, \"key2\": 3}, \"dict_key_test\")\r\n        self.assertEqual(dictionary.to_list(), [(\"gender\", \"male\"), (\"score\", [78, 89])])\r\n        # 2. Add None value\r\n        dictionary.add(\"score\", None)\r\n        self.assertEqual(dictionary.to_list(), [(\"gender\", \"male\"), (\"score\", [78, 89])])\r\n\r\n    # unit test for remove_by_key()\r\n    def test_remove_by_key(self):\r\n        dictionary = Dictionary()\r\n        dictionary.add(\"name\", \"Nick\")\r\n        dictionary.add(\"age\", 23)\r\n        dictionary.add(\"gender\", \"male\")\r\n        dictionary.add(\"others\", 10)\r\n        dictionary.add(\"others\", 100)\r\n        dictionary.remove_by_key(\"gender\")\r\n        self.assertEqual(dictionary.to_list(), [(\"age\", 23), (\"name\", \"Nick\"), (\"others\", [10, 100])])\r\n        dictionary.remove_by_key(\"others\")\r\n        self.assertEqual(dictionary.to_list(), [(\"age\", 23), (\"name\", \"Nick\")])\r\n\r\n        # Exception test\r\n        # 1. Remove elements that do not exist. It's going to have log output on the console.\r\n        dictionary.remove_by_key(23)\r\n        # 2. Remove None key. It's going to have log output on the console.\r\n        dictionary.remove_by_key(None)\r\n\r\n    # unit test for size()\r\n    def test_size(self):\r\n        dictionary = Dictionary()\r\n        dictionary.add(\"name\", \"Nick\")\r\n        dictionary.add(\"age\", 23)\r\n        dictionary.add(\"gender\", \"male\")\r\n        dictionary.add(\"others\", 10)\r\n        dictionary.add(\"others\", 100)\r\n        self.assertEqual(dictionary.size(), [4, 5])\r\n        dictionary.remove_by_key(\"others\")\r\n        self.assertEqual(dictionary.size(), [3, 3])\r\n\r\n    # unit test for to_list()\r\n    def test_to_list(self):\r\n        dictionary = Dictionary()\r\n        self.assertEqual(dictionary.to_list(), [])\r\n        dictionary.add(\"name\", \"Nick\")\r\n        dictionary.add(\"age\", 23)\r\n        dictionary.add(\"gender\", \"male\")\r\n        dictionary.add(\"others\", 10)\r\n        dictionary.add(\"others\", 100)\r\n        self.assertEqual(dictionary.to_list(), [(\"age\", 23), (\"gender\", \"male\"), (\"name\", \"Nick\"), (\"others\", [10, 100])])\r\n\r\n    # unit test for from_list()\r\n    def test_from_list(self):\r\n        lst = [('name', 'Nick'), ('age', 23), ('gender', 'male'), ('others', [10, 100])]\r\n        lst_2 = [('name', 'Nick'), ('age', None), (None, 'male'), ('others', [10, 100, 200])]\r\n        dictionary = Dictionary()\r\n        dictionary.from_list(lst)\r\n        self.assertEqual(dictionary.get_by_key('gender'), 'male')\r\n        self.assertEqual(dictionary.to_list(),\r\n                         [('age', 23), ('gender', 'male'), ('name', 'Nick'), ('others', [10, 100])])\r\n\r\n        # Existing dictionary object with some elements\r\n        dictionary.from_list(lst_2)\r\n        self.assertEqual(dictionary.to_list(),\r\n                         [('age', 23), ('gender', 'male'), ('name', 'Nick'), ('others', [[10, 100], [10, 100, 200]])])\r\n        # Exception test\r\n        # There are invalid key or value in the list.\r\n        dictionary2 = Dictionary()\r\n        dictionary2.from_list(lst_2)\r\n        self.assertEqual(dictionary2.to_list(),\r\n                         [('name', 'Nick'), ('others', [10, 100, 200])])\r\n\r\n    # property-based test\r\n    def test_from_list_to_list_equality(self):\r\n        lst = [('name', 'Nick'), ('age', 23), ('gender', 'male'), ('others', [10, 100])]\r\n        temp = sorted(lst, key=lambda element: element[0])\r\n        dictionary = Dictionary()\r\n        dictionary.from_list(lst)\r\n        self.assertEqual(dictionary.to_list(), temp)\r\n\r\n    # property-based test\r\n    def test_python_len_and_dictionary_size_equality(self):\r\n        lst = [('name', 'Nick'), ('age', 23), ('gender', 'male'), ('others', [10, 100])]\r\n        dictionary = Dictionary()\r\n        dictionary.from_list(lst)\r\n        self.assertEqual(len(dictionary.to_list()), dictionary.size()[0])\r\n\r\n    # unit test for get_by_key()\r\n    def test_get_by_key(self):\r\n        lst = [('name', 'Nick'), ('age', 23), ('gender', 'male'), ('others', [10, 100])]\r\n        dictionary = Dictionary()\r\n        dictionary.from_list(lst)\r\n        self.assertEqual(dictionary.get_by_key(\"others\"), [10, 100])\r\n\r\n        # Exception test\r\n        # 1. Get by the invalid key. It's going to have log output on the console.\r\n        self.assertEqual(dictionary.get_by_key(None), None)\r\n        # 2. Get by the not existing key. It's going to have log output on the console.\r\n        self.assertEqual(dictionary.get_by_key(\"color\"), None)\r\n\r\n    # unit test for filter()\r\n    def test_filter(self):\r\n        # the operation object of the self-defined function should be a key-value pair.\r\n        # pair = (key, value)\r\n        def single_key_filter(pair):\r\n            # filter the key-value pairs that the key consists of single word.\r\n            if not (type(pair[0]) is tuple):\r\n                return pair\r\n            elif (type(pair[0]) is tuple) and (len(pair[0]) == 1):\r\n                return pair\r\n            else:\r\n                return None\r\n\r\n        lst = [((2, 4), 'Nick'), ('age', 23), ('gender', 'male')]\r\n        dictionary = Dictionary()\r\n        dictionary.from_list(lst)\r\n        tmp = sorted(dictionary.filter(single_key_filter), key=lambda element: element[0])\r\n        self.assertEqual(tmp, [('age', 23), ('gender', 'male')])\r\n\r\n    # unit test for map_my()\r\n    def test_map_my(self):\r\n        lst = [('score', [98, {99, 100}]), ('age', 23), ('length', 50)]\r\n        dictionary = Dictionary()\r\n        dictionary.from_list(lst)\r\n        dictionary.map_my(lambda x: x + 1)\r\n        self.assertEqual(dictionary.to_list(), [('age', 24), ('length', 51), ('score', [99, [100, 101]])])\r\n\r\n    # unit test for reduce_my()\r\n    def test_reduce_my(self):\r\n        lst = [('age', [23, 22, 22]), ('score', [101, 100, 99])]\r\n        dictionary = Dictionary()\r\n        dictionary.from_list(lst)\r\n        result = dictionary.reduce_my(lambda y, x: x + y, \"score\", 1)\r\n        self.assertEqual(result, 301)\r\n\r\n    # unit test for iter() and next()\r\n    def test_iter_and_next(self):\r\n        lst = [('score', [98, 99]), ('age', 23), ('length', 50)]\r\n        dictionary = Dictionary()\r\n        dictionary.from_list(lst)\r\n        tmp = []\r\n        for element in dictionary:\r\n            tmp.append((element))\r\n        sorted_tmp = sorted(tmp, key=lambda element: element[0])\r\n        self.assertEqual(dictionary.to_list(), sorted_tmp)\r\n\r\n        it = iter(Dictionary())\r\n        self.assertRaises(StopIteration, lambda: next(it))\r\n\r\n    # property-based test\r\n    # Implement Associativity. For all a, b and c in S, the equation (ab)c = a(bc) holds.\r\n    # S is dictionary objects set.\r\n    def test_mconcat(self):\r\n        list_1 = [('age', 23), ('score', 99)]\r\n        list_2 = [('length', 100)]\r\n        list_3 = [(\"length\", 200), (\"color\", \"red\")]\r\n\r\n        dictionary_1 = Dictionary()\r\n        dictionary_1.from_list(list_1)\r\n        dictionary_2 = Dictionary()\r\n        dictionary_2.from_list(list_2)\r\n        dictionary_3 = Dictionary()\r\n        dictionary_3.from_list(list_3)\r\n\r\n        # It equals to \"(ab)c\".\r\n        dictionary_2.mconcat(dictionary_3)\r\n        dictionary_1.mconcat(dictionary_2)\r\n        temp1 = dictionary_1\r\n\r\n        dictionary_1 = Dictionary()\r\n        dictionary_1.from_list(list_1)\r\n        dictionary_2 = Dictionary()\r\n        dictionary_2.from_list(list_2)\r\n\r\n        # It equals to \"a(bc)\".\r\n        dictionary_2.mconcat(dictionary_1)\r\n        dictionary_3.mconcat(dictionary_2)\r\n        temp2 = dictionary_3\r\n\r\n        # To determine if \"(ab)c\" and \"a(bc)\" are equal\r\n        self.assertEqual(temp1.to_list(), temp2.to_list())\r\n\r\n    # property-based test\r\n    # Implement Identity element There exists an element e (mempty) in S such that for every ele\u0002ment a in S,\r\n    # the equations ea = ae = a hold.\r\n    # \"e\" is Corresponding to the return of mempty() function in the code.\r\n    def test_mempty(self):\r\n        dictionary_1 = Dictionary()\r\n        dictionary_2 = Dictionary()\r\n        dictionary_3 = Dictionary().mempty()\r\n        list_1 = [('age', 23), ('score', 99)]\r\n        dictionary_1.from_list(list_1)\r\n        dictionary_2.from_list(list_1)\r\n        dictionary_4 = dictionary_1\r\n\r\n        # It equals to \"ae\".\r\n        dictionary_1.mconcat(dictionary_3)\r\n        # It equals to \"ea\".\r\n        dictionary_3.mconcat(dictionary_2)\r\n        # To determine if \"ae\" and \"ea\" are equal\r\n        self.assertEqual(dictionary_1.to_list(), dictionary_3.to_list())\r\n        # To determine if \"ae\" and \"a\" are equal\r\n        self.assertEqual(dictionary_1.to_list(), dictionary_4.to_list())\r\n\r\n\r\nif __name__ == '__main__':\r\n    unittest.main()\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Chen/DictionaryTest.py b/src/Chen/DictionaryTest.py
--- a/src/Chen/DictionaryTest.py	(revision e79df35bd2b01f301d3287cc5a8567ec997e4ab6)
+++ b/src/Chen/DictionaryTest.py	(date 1618131663200)
@@ -1,10 +1,5 @@
 import unittest
-from turtle import st
-
-from hypothesis import given
-
 from Dictionary import Dictionary
-# import Dictionary
 
 
 class DictionaryTest(unittest.TestCase):
